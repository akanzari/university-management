(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core')) :
    typeof define === 'function' && define.amd ? define('@ngx-config/core', ['exports', '@angular/core'], factory) :
    (global = global || self, factory((global['ngx-config'] = global['ngx-config'] || {}, global['ngx-config'].core = {}), global.ng.core));
}(this, (function (exports, core) { 'use strict';

    var ConfigLoader = (function () {
        function ConfigLoader() {
        }
        return ConfigLoader;
    }());
    var ConfigStaticLoader = (function () {
        function ConfigStaticLoader(providedSettings) {
            this.providedSettings = providedSettings;
        }
        ConfigStaticLoader.prototype.loadSettings = function () {
            return Promise.resolve(this.providedSettings);
        };
        return ConfigStaticLoader;
    }());

    var ConfigService = (function () {
        function ConfigService(loader) {
            this.loader = loader;
        }
        ConfigService.prototype.init = function () {
            var _this = this;
            return this.loader.loadSettings().then(function (res) { return (_this.settings = res); });
        };
        ConfigService.prototype.getSettings = function (key, defaultValue) {
            if (!key || (Array.isArray(key) && !key[0])) {
                return this.settings;
            }
            var paths = !Array.isArray(key) ? key.split('.') : key;
            var result = paths.reduce(function (acc, current) { return acc && acc[current]; }, this.settings);
            if (result === undefined) {
                result = defaultValue;
                if (result === undefined) {
                    throw new Error("No setting found with the specified key [" + paths.join('/') + "]!");
                }
            }
            return result;
        };
        ConfigService.ɵfac = function ConfigService_Factory(t) { return new (t || ConfigService)(core.ɵɵinject(ConfigLoader)); };
        ConfigService.ɵprov = core.ɵɵdefineInjectable({ token: ConfigService, factory: ConfigService.ɵfac });
        return ConfigService;
    }());
    (function () { core.ɵsetClassMetadata(ConfigService, [{
            type: core.Injectable
        }], function () { return [{ type: ConfigLoader }]; }, null); })();

    var ConfigPipe = (function () {
        function ConfigPipe(config) {
            this.config = config;
        }
        ConfigPipe.prototype.transform = function (value) {
            return this.config.getSettings(value);
        };
        ConfigPipe.ɵfac = function ConfigPipe_Factory(t) { return new (t || ConfigPipe)(core.ɵɵdirectiveInject(ConfigService)); };
        ConfigPipe.ɵpipe = core.ɵɵdefinePipe({ name: "config", type: ConfigPipe, pure: true });
        ConfigPipe.ɵprov = core.ɵɵdefineInjectable({ token: ConfigPipe, factory: ConfigPipe.ɵfac });
        return ConfigPipe;
    }());
    (function () { core.ɵsetClassMetadata(ConfigPipe, [{
            type: core.Injectable
        }, {
            type: core.Pipe,
            args: [{
                    name: 'config'
                }]
        }], function () { return [{ type: ConfigService }]; }, null); })();

    var configFactory = function () { return new ConfigStaticLoader(); };
    var initializerFactory = function (config) {
        var res = function () { return config.init(); };
        return res;
    };
    var CONFIG_FORROOT_GUARD = new core.InjectionToken('CONFIG_FORROOT_GUARD');
    function provideForRootGuard(config) {
        if (config) {
            throw new Error("ConfigModule.forRoot() called twice. Lazy loaded modules should use ConfigModule.forChild() instead.");
        }
        return 'guarded';
    }
    var ConfigModule = (function () {
        function ConfigModule(guard) {
        }
        ConfigModule.forRoot = function (configuredProvider) {
            if (configuredProvider === void 0) { configuredProvider = {
                provide: ConfigLoader,
                useFactory: configFactory
            }; }
            return {
                ngModule: ConfigModule,
                providers: [
                    configuredProvider,
                    ConfigService,
                    {
                        provide: core.APP_INITIALIZER,
                        useFactory: initializerFactory,
                        deps: [ConfigService],
                        multi: true
                    },
                    {
                        provide: CONFIG_FORROOT_GUARD,
                        useFactory: provideForRootGuard,
                        deps: [[ConfigService, new core.Optional(), new core.SkipSelf()]]
                    }
                ]
            };
        };
        ConfigModule.forChild = function () {
            return {
                ngModule: ConfigModule
            };
        };
        ConfigModule.ɵmod = core.ɵɵdefineNgModule({ type: ConfigModule });
        ConfigModule.ɵinj = core.ɵɵdefineInjector({ factory: function ConfigModule_Factory(t) { return new (t || ConfigModule)(core.ɵɵinject(CONFIG_FORROOT_GUARD, 8)); } });
        return ConfigModule;
    }());
    (function () { (typeof ngJitMode === "undefined" || ngJitMode) && core.ɵɵsetNgModuleScope(ConfigModule, { declarations: [ConfigPipe], exports: [ConfigPipe] }); })();
    (function () { core.ɵsetClassMetadata(ConfigModule, [{
            type: core.NgModule,
            args: [{
                    declarations: [ConfigPipe],
                    exports: [ConfigPipe]
                }]
        }], function () { return [{ type: undefined, decorators: [{
                    type: core.Optional
                }, {
                    type: core.Inject,
                    args: [CONFIG_FORROOT_GUARD]
                }] }]; }, null); })();

    exports.CONFIG_FORROOT_GUARD = CONFIG_FORROOT_GUARD;
    exports.ConfigLoader = ConfigLoader;
    exports.ConfigModule = ConfigModule;
    exports.ConfigPipe = ConfigPipe;
    exports.ConfigService = ConfigService;
    exports.ConfigStaticLoader = ConfigStaticLoader;
    exports.configFactory = configFactory;
    exports.initializerFactory = initializerFactory;
    exports.provideForRootGuard = provideForRootGuard;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ngx-config-core.umd.js.map
