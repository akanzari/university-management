import { ɵɵinject, ɵɵdefineInjectable, ɵsetClassMetadata, Injectable, ɵɵdirectiveInject, ɵɵdefinePipe, Pipe, InjectionToken, APP_INITIALIZER, Optional, SkipSelf, ɵɵdefineNgModule, ɵɵdefineInjector, ɵɵsetNgModuleScope, NgModule, Inject } from '@angular/core';

var ConfigLoader = (function () {
    function ConfigLoader() {
    }
    return ConfigLoader;
}());
var ConfigStaticLoader = (function () {
    function ConfigStaticLoader(providedSettings) {
        this.providedSettings = providedSettings;
    }
    ConfigStaticLoader.prototype.loadSettings = function () {
        return Promise.resolve(this.providedSettings);
    };
    return ConfigStaticLoader;
}());

var ConfigService = (function () {
    function ConfigService(loader) {
        this.loader = loader;
    }
    ConfigService.prototype.init = function () {
        var _this = this;
        return this.loader.loadSettings().then(function (res) { return (_this.settings = res); });
    };
    ConfigService.prototype.getSettings = function (key, defaultValue) {
        if (!key || (Array.isArray(key) && !key[0])) {
            return this.settings;
        }
        var paths = !Array.isArray(key) ? key.split('.') : key;
        var result = paths.reduce(function (acc, current) { return acc && acc[current]; }, this.settings);
        if (result === undefined) {
            result = defaultValue;
            if (result === undefined) {
                throw new Error("No setting found with the specified key [" + paths.join('/') + "]!");
            }
        }
        return result;
    };
    ConfigService.ɵfac = function ConfigService_Factory(t) { return new (t || ConfigService)(ɵɵinject(ConfigLoader)); };
    ConfigService.ɵprov = ɵɵdefineInjectable({ token: ConfigService, factory: ConfigService.ɵfac });
    return ConfigService;
}());
(function () { ɵsetClassMetadata(ConfigService, [{
        type: Injectable
    }], function () { return [{ type: ConfigLoader }]; }, null); })();

var ConfigPipe = (function () {
    function ConfigPipe(config) {
        this.config = config;
    }
    ConfigPipe.prototype.transform = function (value) {
        return this.config.getSettings(value);
    };
    ConfigPipe.ɵfac = function ConfigPipe_Factory(t) { return new (t || ConfigPipe)(ɵɵdirectiveInject(ConfigService)); };
    ConfigPipe.ɵpipe = ɵɵdefinePipe({ name: "config", type: ConfigPipe, pure: true });
    ConfigPipe.ɵprov = ɵɵdefineInjectable({ token: ConfigPipe, factory: ConfigPipe.ɵfac });
    return ConfigPipe;
}());
(function () { ɵsetClassMetadata(ConfigPipe, [{
        type: Injectable
    }, {
        type: Pipe,
        args: [{
                name: 'config'
            }]
    }], function () { return [{ type: ConfigService }]; }, null); })();

var configFactory = function () { return new ConfigStaticLoader(); };
var initializerFactory = function (config) {
    var res = function () { return config.init(); };
    return res;
};
var CONFIG_FORROOT_GUARD = new InjectionToken('CONFIG_FORROOT_GUARD');
function provideForRootGuard(config) {
    if (config) {
        throw new Error("ConfigModule.forRoot() called twice. Lazy loaded modules should use ConfigModule.forChild() instead.");
    }
    return 'guarded';
}
var ConfigModule = (function () {
    function ConfigModule(guard) {
    }
    ConfigModule.forRoot = function (configuredProvider) {
        if (configuredProvider === void 0) { configuredProvider = {
            provide: ConfigLoader,
            useFactory: configFactory
        }; }
        return {
            ngModule: ConfigModule,
            providers: [
                configuredProvider,
                ConfigService,
                {
                    provide: APP_INITIALIZER,
                    useFactory: initializerFactory,
                    deps: [ConfigService],
                    multi: true
                },
                {
                    provide: CONFIG_FORROOT_GUARD,
                    useFactory: provideForRootGuard,
                    deps: [[ConfigService, new Optional(), new SkipSelf()]]
                }
            ]
        };
    };
    ConfigModule.forChild = function () {
        return {
            ngModule: ConfigModule
        };
    };
    ConfigModule.ɵmod = ɵɵdefineNgModule({ type: ConfigModule });
    ConfigModule.ɵinj = ɵɵdefineInjector({ factory: function ConfigModule_Factory(t) { return new (t || ConfigModule)(ɵɵinject(CONFIG_FORROOT_GUARD, 8)); } });
    return ConfigModule;
}());
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(ConfigModule, { declarations: [ConfigPipe], exports: [ConfigPipe] }); })();
(function () { ɵsetClassMetadata(ConfigModule, [{
        type: NgModule,
        args: [{
                declarations: [ConfigPipe],
                exports: [ConfigPipe]
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [CONFIG_FORROOT_GUARD]
            }] }]; }, null); })();

export { CONFIG_FORROOT_GUARD, ConfigLoader, ConfigModule, ConfigPipe, ConfigService, ConfigStaticLoader, configFactory, initializerFactory, provideForRootGuard };
//# sourceMappingURL=ngx-config-core.js.map
