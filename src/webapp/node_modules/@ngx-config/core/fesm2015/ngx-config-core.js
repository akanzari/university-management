import { ɵɵinject, ɵɵdefineInjectable, ɵsetClassMetadata, Injectable, ɵɵdirectiveInject, ɵɵdefinePipe, Pipe, InjectionToken, APP_INITIALIZER, Optional, SkipSelf, ɵɵdefineNgModule, ɵɵdefineInjector, ɵɵsetNgModuleScope, NgModule, Inject } from '@angular/core';

class ConfigLoader {
}
class ConfigStaticLoader {
    constructor(providedSettings) {
        this.providedSettings = providedSettings;
    }
    loadSettings() {
        return Promise.resolve(this.providedSettings);
    }
}

class ConfigService {
    constructor(loader) {
        this.loader = loader;
    }
    init() {
        return this.loader.loadSettings().then((res) => (this.settings = res));
    }
    getSettings(key, defaultValue) {
        if (!key || (Array.isArray(key) && !key[0])) {
            return this.settings;
        }
        const paths = !Array.isArray(key) ? key.split('.') : key;
        let result = paths.reduce((acc, current) => acc && acc[current], this.settings);
        if (result === undefined) {
            result = defaultValue;
            if (result === undefined) {
                throw new Error(`No setting found with the specified key [${paths.join('/')}]!`);
            }
        }
        return result;
    }
}
ConfigService.ɵfac = function ConfigService_Factory(t) { return new (t || ConfigService)(ɵɵinject(ConfigLoader)); };
ConfigService.ɵprov = ɵɵdefineInjectable({ token: ConfigService, factory: ConfigService.ɵfac });
(function () { ɵsetClassMetadata(ConfigService, [{
        type: Injectable
    }], function () { return [{ type: ConfigLoader }]; }, null); })();

class ConfigPipe {
    constructor(config) {
        this.config = config;
    }
    transform(value) {
        return this.config.getSettings(value);
    }
}
ConfigPipe.ɵfac = function ConfigPipe_Factory(t) { return new (t || ConfigPipe)(ɵɵdirectiveInject(ConfigService)); };
ConfigPipe.ɵpipe = ɵɵdefinePipe({ name: "config", type: ConfigPipe, pure: true });
ConfigPipe.ɵprov = ɵɵdefineInjectable({ token: ConfigPipe, factory: ConfigPipe.ɵfac });
(function () { ɵsetClassMetadata(ConfigPipe, [{
        type: Injectable
    }, {
        type: Pipe,
        args: [{
                name: 'config'
            }]
    }], function () { return [{ type: ConfigService }]; }, null); })();

const configFactory = () => new ConfigStaticLoader();
const initializerFactory = (config) => {
    const res = () => config.init();
    return res;
};
const CONFIG_FORROOT_GUARD = new InjectionToken('CONFIG_FORROOT_GUARD');
function provideForRootGuard(config) {
    if (config) {
        throw new Error(`ConfigModule.forRoot() called twice. Lazy loaded modules should use ConfigModule.forChild() instead.`);
    }
    return 'guarded';
}
class ConfigModule {
    constructor(guard) { }
    static forRoot(configuredProvider = {
        provide: ConfigLoader,
        useFactory: configFactory
    }) {
        return {
            ngModule: ConfigModule,
            providers: [
                configuredProvider,
                ConfigService,
                {
                    provide: APP_INITIALIZER,
                    useFactory: initializerFactory,
                    deps: [ConfigService],
                    multi: true
                },
                {
                    provide: CONFIG_FORROOT_GUARD,
                    useFactory: provideForRootGuard,
                    deps: [[ConfigService, new Optional(), new SkipSelf()]]
                }
            ]
        };
    }
    static forChild() {
        return {
            ngModule: ConfigModule
        };
    }
}
ConfigModule.ɵmod = ɵɵdefineNgModule({ type: ConfigModule });
ConfigModule.ɵinj = ɵɵdefineInjector({ factory: function ConfigModule_Factory(t) { return new (t || ConfigModule)(ɵɵinject(CONFIG_FORROOT_GUARD, 8)); } });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(ConfigModule, { declarations: [ConfigPipe], exports: [ConfigPipe] }); })();
(function () { ɵsetClassMetadata(ConfigModule, [{
        type: NgModule,
        args: [{
                declarations: [ConfigPipe],
                exports: [ConfigPipe]
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [CONFIG_FORROOT_GUARD]
            }] }]; }, null); })();

export { CONFIG_FORROOT_GUARD, ConfigLoader, ConfigModule, ConfigPipe, ConfigService, ConfigStaticLoader, configFactory, initializerFactory, provideForRootGuard };
//# sourceMappingURL=ngx-config-core.js.map
